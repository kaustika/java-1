# spbstu-amd-java

В курсе 4 лабораторные работы. Они вместе складываются в один проект - многопоточный архиватор.

[jar для второй](https://drive.google.com/open?id=1V1403Yh38zu5KnZhIjAyO3Tafi8ATXpO). 
Код второй в ветке lab2

[jar для третьей](https://drive.google.com/open?id=1sYT5ZSvtTemLk1aUKl89PxvsbyJ8ovta)


## Разное

Вопросы и пожелания, пожалуйста, пишите в [issues](https://github.com/kystyn/java/issues).


## Общие требования

- SDK 1.8 (Java8 и меньше, соответственно)
- Максимально избегайте хардкода, разделяйте код и данные. 
Например, информация о формате конфигурационного файла должна хваниться в статических полях класса-парсера
(какие символы-разделители используется и т.п.).
- Функция, которую задает алгоритм, должна быть биективной 
(т.е. последовательно применения архиватора и деархиватора должно давать исходный файл).
- Алгоритм должен быть 
[поточным](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC),
т.е. при любом объеме входных данных использовать константное количество оперативной памяти.
(иначе как кино в 40 гигов архивировать).
Таким образом, приложение в цикле должно читать блоки фиксированного размера из файла и 
их последовательно обрабатывать (и сразу записывать в выходной файл), 
пока входной файл не кончится.


## Lab 1

1. Реализовать алгоритм кодирования по вариантам.
2. Реализовать простейшее приложение-архиватор.

#### Пользовательский интерфейс приложения

- Приложение принимает один аргумент командной строки - путь к кнфигурационному файлу.
- В конфиге содержится вся информация для работы приложения. Грамматика конфига произвольная.
    - Мод работы (архивировать/деархивировать).
    - Размер буфера.
    - Входной и выходной файлы.
    - мб еще что-нибудь...
- Пользователю в `stdout` должны выводиться осмысленные ошибки, 
не надо пугать пользователя! (т.е. не падать просто на исключениях)
- Подробные данные об ошибках писать в лог. Можно использовать `java.util.logging.Logger'.


## Lab 2

- см Lab3
- отличия от третьей
    - При знакомстве сохраняют ссылки друг на друга, не более.
    - С забирает данные не через какой-то ```DataAccessor```, а напрямую через ```get()```.


## Lab 3

### UPD

- Ниже описывается контракт для интерфейса `Executor`. 
Гарантируется что при дословном его соблюдении любые две реализации смогут ужиться и работать вместе.
- Никто не запрещает выполнять его лишь частично (например, забить на кодировки).
Но тогда нет гарантии абсолютной совместимости.
- Постулируется лишь интерфейс `Executor`, все остальное можно менять как угодно.
Например, сделать ```interface MyReader extends Reader, Fallible {}```. 


### Знакомство

Manager читает конфиг и выстраивает экзекуторов на конвейер. 
Делает он это в порядке, описанном в конфиге. 
Конвейер получается знакомством соседних экзекуторов.

Считаем что у нас на руках два экзекутора, P и С со статусами OK. Будем их знакомить.

1. ```P.addConsumer(C);```
    - тут P просто сохраняет ссылку на C.
2. ```C.addProducer(P);```
    1. C вызывает ```P.outputDataTypes()```
    2. ```P.outputDataTypes()``` возвращает множество строк - имена типов, 
    в виде которых P может отдавать данные.
    3. С из множества имен типов выбирает один - тот, 
    в каком C хочет получать данные (напр, ```byte[]```).
        - Если же желаемого типа не оказалось, C ставит
        ```status = Status.EXECUTOR_ERROR``` и прекращает общение.
    4. С вызывает ```P.getAccessor(byte[].class.getCanonicalName)``` 
    (подставляем имя того типа, который выбрали).
    5. ```P.getAccessor``` возвращает экземпляр класса, 
    который у продьюсера вложенный и унаследован от ```Producer.DataAccessor```.
    C сохраняет у себя этот экземпляр.
    
На этом знакомство закончилось!

##### DataAccessor

Посмотрим что это такое. Вот пример куска кода продьюсера:
```

private Object output;

private final class DataAccessor implements Producer.DataAccessor {

    @NotNull
    @Override
    public Object get() {
        return output;  // некоторое поле в P
    }

    @Override
    public long size() {
        Objects.requireNonNull(output);
        
        // тут мы знаем, что output это массив, 
        // если строка, вернули бы ((String) output).length()
        return ((byte[]) output).length;  
    }
}

@NotNull
@Override
public Producer.DataAccessor getAccessor(@NotNull final String typeName) {
    // сохраняем себе имя типа, в который будем конвертировать перед отдачей.
    this.outputTypeName = typeName; 
    return new DataAccessor();
}
```

Таким образом, ```DataAccessor``` позволяет C ходить в P и забирать данные.

Также, ```DataAccessor``` может в ```get()``` содержать логику конвертации в выбранный С тип данных,
зависит от реализации.


### Рабочий процесс конвейера

Итак, мы познакомили всех экзекуторов, тем самым сделали конвейер.

##### Запуск!

1. Manager (M) вызывает у первого на конвейере, ридера (R), метод ```R.run()```.
2. В ```run()``` ридер в цикле читает файл по блокам и отправляет на конвейер, работает как продьюсер.

##### Взаимодействие P и C

Допустим, продьюсер обработал данные 
(если продьюсер здесь это ридер, то просто прочитал данные из файла),
сконвертировал в нужный C тип и сложил в переменную output. 
(если произошла ошибка в конвертации или обработке, ставим ```status = Status.EXECUTOR_ERROR``` и делаем ```return```,
не трогая C).

Т.е. мы находимся в методе ```run()``` у P.

Дальше:
1. P вызывает у C ```C.loadDataFrom(this);```
    1. Там С забирает ссылку на данные у продьюсера через сохраненный аксессор:
    ```input = dataAccessor.get()```
    2. Если размер у данных (```dataAccessor.size()```) не равен ожидаемому, ```return 0```
    3. Иначе ```return dataAccessor.size();```
2. P смотрит что вернул ```C.loadDataFrom(this);```
    1. Если вернулся ноль, ставим ```status = Status.EXECUTOR_ERROR;``` и делаем ```return```
    2. Если не ноль, вызываем ```C.run()```
3. После того как ```C.run()``` отработал, ставим ```this.status = C.status()```
    - таким образом статус ошибки, если появится, дойдет до R и тот завершит цикл.
    

### Типы
- поддерживаем
    - byte[]
    - char[]
    - String
- Входной файл должен быть в кодировке UTF-16BE
(можно в idea выбрать справа снизу и переконвертировать)
- Тогда конвертация в коде ваглядит так:
    - ```new String(chars).getBytes("UTF-16BE")``` (char\[\] -> byte\[\])c
    - ```new String(bytes, "UTF-16BE").toCharArray()``` (byte\[\] -> char\[\])
    - к тому же можно полагаться что размер ```byte[]``` в этой кодировке
    будет вдвое длиннее соттветствующего ```char[]```



## Lab 4

__Необходимо реализовать распараллеливание конвейера на n потоков. Каждый из n executor'ов выполняется параллельно с другими, `Reader` и `Writer` в единственном экземпляре.__
- Схема следующая: ```Reader – Executor1 – Writer```, не подразумевается ни распараллеливание после `E1`, ни добавление линейно еще одного `E` после первого. Распараллеливание происходит только после `R` и заканчивается на `W`. Для сдачи достаточно реализовать «ромб».
- Можно написать свой интерфейс, обмениваться `executor`'ами мы не будем. Можно сделать на интерфейсе 2 лабы, чтобы не запариваться с `dataAccessor()`.
- Итак, `Manager` получает данные о количестве потоков из своего конфига, знакомит работников с `R` и `W`, выставляя их на конвейер, а также создает для каждого `E`, `W` и `R` свой ```Thread thr = new Thread(E);``` и запускает его. 
- Внутри `run` каждого из работников находится цикл, который периодически спрашивает у `Producer`, есть ли данные, и если есть – обрабатывает, если нет – тред спит. Таким образом, `R` только делает ```consumer.loaddatafrom()``` в цикле после считывания данных, но никак не ```consumer.run()```.
- `Writer` может получить данные от `E` не в том порядке, в котором нужно. Поэтому он смотрит на своих `producers`, которые лежат в его `List<Producer>`, сравнивает ссылки и понимает, откуда к нему пришли данные. Пока данные не придут от всех `P`, `Thread(Writer)` спит. @kystyn предложил поставить счетчик и плюсовать его, когда данные будут приходить. Когда количество блоков данных будет равно количеству `producers`, `W` сконкатенирует полученные строки в том порядке, в каком `Producers` лежат у него в `ArrayList` и запишет в поток. Пока данные не пришли или пришли не от всех `P`, `Writer` спит.
- Когда у `Reader` закончится считывание, он передаст 0 своим `consumers` (`loadData` вернет 0), далее `C` передаст его `Writer`’у. Так, поток `W` закроется, затем по цепочке закроется поток его `P` и `R`. Закрывать потоки из `Manager` не нужно.
- Также не нужно разделять по потокам данные, считанные `Reader`: `R` считывает порцию данных, размер которой прописан у него в конфиге, запускает первый `thread`, затем считывает еще одну порцию, запускает следующий и так далее.


